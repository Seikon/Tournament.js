
var MODE_ENUM = {
	
	NORMAL: 0,
	DIVIDED: 1
}

function Tournament(canvas,cellHeight,cellWidth,participants,cellsColor,fontColor,backgroundColor,bracketsColor,mode) {
	
	//--Dimensions--
    this.cellHeight = cellHeight;
	this.cellWidth = cellWidth;
	this.textWidth;
	this.textHeight;
	this.roundWidth;
	this.textmargin = 10;
	//References
	this.self = this;
	//--Tournament Abstractions--
	this.cellCords = [];
	this.participants = participants;
	//---Style---
	this.cellsColor = cellsColor;
	this.fontColor = fontColor;
	this.backgroundColor = backgroundColor;
	this.bracketsColor = bracketsColor;
	//---Canvas--
	this.ctx = this.canvas.getContext("2d");
	this.canvas = canvas;
	//--Intervals--
	this.animationIntervals = [];
	//--Enums--
	this.mode = mode;
}

Tournament.prototype.init = function() {
	
	this.roundWidth = this.cellWidth * 1.67;
	
	//The Number of the total rounds is given by the log 2 base of the number of participants.
	this.totalRounds = Math.log2(this.participants.length / 2);
	//Size of fade out transit refresh 
	// -2 to recalculate canvas text error drawing
	this.textWidth = (this.cellWidth -2) / 1.2;
	this.textHeight = this.cellHeight / 1.5;
	//Reference self object to access it in another running context like intervals,timeOut,objects events...
	this.self = this;
	//Reference to father(Tournament.js) in canvas to access atribute members in canvas event listeners
	this.canvas.objectParent = this.self;
	//Color canvas
	this.canvas.style.backgroundColor = this.backgroundColor;
	//Events listener
	this.canvas.addEventListener("mousedown",this.touchStartHandler,false);
	this.canvas.addEventListener("touchstart",this.touchStartHandler,false);
	
}

Tournament.prototype.fadeOut = function(text,x,y,width,height,font) {
					
				context = this.ctx;
				
				self = this;
				
				self.canvas.removeEventListener("mousedown",this.touchStartHandler,false);
								
				alpha = 0.0;
				
				var intervals = this.animationIntervals;
				
				if(intervals.length === 0)
					indice = 0;
				else
					indice = intervals.length;
				
				this.animationIntervals[indice] = setInterval(function () {
					
					context.clearRect(x - 1,y - 20,width,height);
					
					context.fillStyle = "rgba("+ self.fontColor[0] +","+self.fontColor[1]+","+self.fontColor[2]+","+ alpha +")";
					context.font = font;
					context.fillText(text,x,y);
					
					alpha += 0.03;
					
					if(alpha > 1) {
						
						clearInterval(intervals[intervals.length-1]);
						intervals.splice(intervals.length-1,1)	

						if(intervals.length === 0)
							self.canvas.addEventListener("mousedown",self.touchStartHandler,false);
						
					}
					
				},20);
								
}

Tournament.prototype.touchStartHandler = function(e) {
				
	var rect = this.getBoundingClientRect();
	
	var xMouse = e.clientX;
	var yMouse = e.clientY;
	
	var xCanvas = xMouse - rect.left;
	var yCanvas = yMouse - rect.top;
	
	var participant = coliderDetection(xCanvas,yCanvas,this.objectParent.cellCords);
	
	if (participant != null) 
	{
		this.objectParent.moveNextRound(participant);
		
	}
		
}

Tournament.prototype.moveNextRound = function(participant) {
	
	
	var destiny = this.calculateNextRound(participant);
	
	for(i=0; i < this.cellCords.length;i++)
	{
		if(this.cellCords[i].round === destiny.round && this.cellCords[i].cell === destiny.cell)
		{
			this.cellCords[i].element = participant.element;
			this.drawParticipant(this.cellCords[i],true);
		}

	}
	
}

Tournament.prototype.calculateNextRound = function(participant) {
	
	var round = participant.round + 1;
	var cell = Math.floor(participant.cell / 2);
	
	return {round: round,cell: cell};
}

Tournament.prototype.drawParticipant = function(participant,animation) {
	
				if(animation) {
					
					this.fadeOut(participant.element,((participant.x0 + participant.x1) / 2) - this.cellWidth / 2.5,((participant.y0 + participant.y1) / 2) + (this.cellHeight / 4.5),this.textWidth,this.textHeight,"1.5em Impact")
					
				} else {
						
				this.ctx.font = "1.5em Impact";
				//Erase
				this.ctx.fillStyle = '#ffffff';
				this.ctx.clearRect(participant.x0 + 5,participant.y0 + 5,this.cellWidth - 10 ,this.cellHeight -10);
				//Write				
				this.ctx.fillStyle = '#000000';
				this.ctx.fillText(participant.element,((participant.x0 + participant.x1) / 2) - this.cellWidth / 2.5,((participant.y0 + participant.y1) / 2) + (this.cellHeight / 4.5),this.cellWidth,this.cellHeight);
					
				}
}


function coliderDetection (x,y,arrayCords) {
	
	for(i=0; i < arrayCords.length; i++) 
	{
		if(x >= arrayCords[i].x0 && x <= arrayCords[i].x1)
		{

			if(y >= arrayCords[i].y0 && y <= arrayCords[i].y1)
					return arrayCords[i];
			
		}
	}
	
	return null;
}

//Generate Tournament based on Mode enum.
//The tournament it can be generated by this way or calling each method(Generate Cells, Generate Brackects, Locate Participants) separatelly implements animations and visual effects
Tournament.prototype.generateTournament = function() {
	
		switch(this.mode) {
			
			case MODE_ENUM.NORMAL:
				//
				this.generateCells();
				this.generateBrackets();
				this.locateParticipants();
				break;
				
			case MODE_ENUM.DIVIDED:
				
				this.generateCellsDivided();
				this.generateBracketsDivided();
				this.locateParticipants();
				break;
			
			
		}
	
	}

Tournament.prototype.generateCells = function() {
	

	
			for(i = 0; i < Math.log2(this.participants.length) + 1; i++) 
			{
				this.ctx.strokeStyle = this.bracketsColor;
		
				switch(i)
				{
					case 0:
						for(j=0; j < this.participants.length; j++) 
						{
							this.ctx.strokeRect(this.roundWidth * i,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),this.cellWidth,this.cellHeight);
							this.cellCords.push(
												{ x0:this.roundWidth * i,
												  x1: this.roundWidth * i + this.cellWidth,
												  y0:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),
												  y1: (this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight,
												  round: i,
												  cell: j,
												});
						}
					break;
				
					case Math.log2(this.participants.length):
						this.ctx.strokeRect(this.roundWidth * i,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (0 * Math.pow(2, i + 1))),this.cellWidth,this.cellHeight);
						this.cellCords.push(
										    { x0:this.roundWidth * i,
											  x1: this.roundWidth * i + this.cellWidth,
											  y0:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (0 * Math.pow(2, i + 1))),
											  y1: (this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (0 * Math.pow(2, i + 1))) + this.cellHeight,
											  round: i,
											  cell: 0,
											});
					break;
				
					default:
						for(j=0; j < this.participants.length / Math.pow(2,i); j++) 
						{
							this.ctx.strokeRect(this.roundWidth * i,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),this.cellWidth,this.cellHeight);
							this.cellCords.push(
												{ x0:this.roundWidth * i,
												  x1: this.roundWidth * i + this.cellWidth,
												  y0:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),
												  y1: (this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight,
												  round: i,
												  cell: j,
												});
						}
					break;
				}
			}
			
			this.self = this;
			
}

Tournament.prototype.generateCellsDivided = function() {
	
	for(i = 0; i <= this.totalRounds + 1; i++) 
	{
				this.ctx.strokeStyle = this.bracketsColor;
		
				switch(i) 
				{
					case 0:
						for(j = 0; j < this.participants.length / 2; j++)
						{	
							//First Node
							this.ctx.strokeRect(this.roundWidth * i,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),this.cellWidth,this.cellHeight);
							this.cellCords.push(
												{ x0:this.roundWidth * i,
												  x1:this.roundWidth * i + this.cellWidth,
												  y0:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),
												  y1: (this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight,
												  round: i,
												  cell: j,
												});
							
							//Second Node
							this.ctx.strokeRect(this.roundWidth * Math.log2(this.participants.length) * 2 - this.roundWidth,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),this.cellWidth,this.cellHeight);
							this.cellCords.push(
												{ x0:this.roundWidth * Math.log2(this.participants.length) * 2 - this.roundWidth,
												  x1:this.roundWidth * Math.log2(this.participants.length) * 2 - this.roundWidth + this.cellWidth,
												  y0:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),
												  y1:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight,
												  round:i,
												  cell:j + this.participants.length / 2,
							});
						}
							
					break;
					
					case this.totalRounds + 1:
						this.ctx.strokeRect(this.roundWidth * i - this.cellWidth / 1.2,(this.cellHeight *  Math.pow(2, i -1) - (this.cellHeight)) + (this.cellHeight * 2),this.cellWidth,this.cellHeight);
						
						this.cellCords.push(
										    { x0:this.roundWidth * i - this.cellWidth / 1.2,
											  x1: this.roundWidth * i - this.cellWidth / 1.2 + this.cellWidth,
											  y0:(this.cellHeight *  Math.pow(2, i -1) - (this.cellHeight)) + (this.cellHeight * 2),
											  y1: (this.cellHeight *  Math.pow(2, i -1) - (this.cellHeight)) + (this.cellHeight * 2) + this.cellHeight,
											  round: i,
											  cell: 0,
											});	
						break;
										
					case Math.log2(this.participants.length / 2):
						//First Node
						this.ctx.strokeRect(this.roundWidth * i,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (0 * Math.pow(2, i + 1))),this.cellWidth,this.cellHeight);
						
						this.cellCords.push(
										    { x0:this.roundWidth * i,
											  x1: this.roundWidth * i + this.cellWidth,
											  y0:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (0 * Math.pow(2, i + 1))),
											  y1: (this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (0 * Math.pow(2, i + 1))) + this.cellHeight,
											  round: i,
											  cell: 0,
											});
						//Last Node
						this.ctx.strokeRect(this.roundWidth * Math.log2(this.participants.length),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (0 * Math.pow(2, i + 1))),this.cellWidth,this.cellHeight);
						this.cellCords.push(
										    { x0:this.roundWidth * Math.log2(this.participants.length),
											  x1: this.roundWidth * Math.log2(this.participants.length) + this.cellWidth,
											  y0:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (0 * Math.pow(2, i + 1))),
											  y1: (this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (0 * Math.pow(2, i + 1))) + this.cellHeight,
											  round: i,
											  cell: 1,
											});		
					break;
					
					default:
						for(j = 0; j < this.participants.length / (Math.pow(2,i) * 2); j++)
						{
							//First Node
							this.ctx.strokeRect(this.roundWidth * i,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),this.cellWidth,this.cellHeight);
							this.cellCords.push(
												{ x0:this.roundWidth * i,
												  x1: this.roundWidth * i + this.cellWidth,
												  y0:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),
												  y1: (this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight,
												  round: i,
												  cell: j,
												});
							//Second Node
							this.ctx.strokeRect(this.roundWidth * this.totalRounds + (this.roundWidth * (Math.log2(this.participants.length / 2)) - ((i -1) * this.roundWidth)),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),this.cellWidth,this.cellHeight);
							this.cellCords.push(
												{ x0:this.roundWidth * this.totalRounds + (this.roundWidth * (Math.log2(this.participants.length / 2)) - ((i -1) * this.roundWidth)),
												  x1:this.roundWidth * this.totalRounds + (this.roundWidth * (Math.log2(this.participants.length / 2)) - ((i -1) * this.roundWidth)) + this.cellWidth,
												  y0:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))),
												  y1:(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight,
												  round:i,
												  cell:Math.floor(j + this.participants.length / (2 * (i + 1))),
							});
						}
					break;
					
					
				}
	}
			
			this.self = this;
	
	
}

Tournament.prototype.generateBrackets = function() {
	
	
		for(i = 0; i < Math.log2(this.participants.length) + 1; i++) 
		{
		
			switch(i)
			{
				case 0:
					for(j=0; j < this.participants.length; j++) 
					{
						//horizontal movement
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4 ,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.stroke();
						
						if(j % 2 ==0) 
						{
						//vertical movement
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,((this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2) + (this.cellHeight * Math.pow(2, i + 1)));
						this.ctx.stroke();
						
						//Relation Line
						this.ctx.beginPath();
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 2.5,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i)+ this.cellHeight / 2);
						this.ctx.stroke();
						
						}
					}
				break;
				
				case Math.log2(this.participants.length):
				break;
				
				default:
					for(j=0; j < this.participants.length / Math.pow(2,i); j++) 
					{
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4 ,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.stroke();
						
						if(j % 2 ==0) 
						{
						//vertical movement
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,((this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2) + (this.cellHeight * Math.pow(2, i + 1)));
						this.ctx.stroke();
						
						//Relation Line
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 2.5,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i)+ this.cellHeight / 2);
						this.ctx.stroke();
						
						}
					}
				break;
			}
			
		}
		
		this.self = this;
			
}

Tournament.prototype.generateBracketsDivided = function() {
	
	
		for(i = 0; i <= Math.log2(this.participants.length / 2); i++) 
		{
		
			switch(i)
			{
				case 0:
					for(j=0; j < this.participants.length / 2; j++) 
					{
						//horizontal movement D1
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4 ,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.stroke();
						//horizontal movement D2
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo(this.roundWidth * Math.log2(this.participants.length) * 2 - this.roundWidth ,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo(this.roundWidth * Math.log2(this.participants.length) * 2 - this.roundWidth  - (this.roundWidth / 4),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.stroke();						
						
						if(j % 2 ==0) 
						{
						//vertical movement D1
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,((this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2) + (this.cellHeight * Math.pow(2, i + 1)));
						this.ctx.stroke();
						//vertical movement D2
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo(this.roundWidth * Math.log2(this.participants.length) * 2 - this.roundWidth  - (this.roundWidth / 4),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo(this.roundWidth * Math.log2(this.participants.length) * 2 - this.roundWidth  - (this.roundWidth / 4),((this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2) + (this.cellHeight * Math.pow(2, i + 1)));
						this.ctx.stroke();
						//Relation Line D1
						this.ctx.beginPath();
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 2.5,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i)+ this.cellHeight / 2);
						this.ctx.stroke();
						//Relation Line 2 D2
						this.ctx.beginPath();
						this.ctx.moveTo(this.roundWidth * Math.log2(this.participants.length) * 2 - this.roundWidth   - (this.roundWidth / 4),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i) + this.cellHeight / 2);
						this.ctx.lineTo(this.roundWidth * Math.log2(this.participants.length) * 2 - this.roundWidth   - (this.roundWidth / 2.5),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i)+ this.cellHeight / 2);
						this.ctx.stroke();
						}
					}
				break;
				
				case Math.log2(this.participants.length / 2):
						//Horizontal Movement
						this.ctx.beginPath();
						this.ctx.moveTo((this.roundWidth * i + this.cellWidth) + (this.cellWidth / 3),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight / 2),this.cellWidth,this.cellHeight);
						this.ctx.lineTo((this.roundWidth * i + this.cellWidth) + (this.cellWidth / 3),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * 2),this.cellWidth,this.cellHeight);
						this.ctx.stroke();
						//Relation
						this.ctx.beginPath();
						this.ctx.moveTo(this.roundWidth * i + this.cellWidth,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight / 2),this.cellWidth,this.cellHeight);
						this.ctx.lineTo((this.roundWidth * i + this.cellWidth) + (this.cellWidth / 1.5),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight / 2),this.cellWidth,this.cellHeight);						
						this.ctx.stroke();						
				break;
				
				default:
					for(j=0; j < this.participants.length / Math.pow(2,i) / 2; j++) 
					{	
						//horizontal movement D1
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4 ,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.stroke();
						////horizontal movement D2
						this.ctx.beginPath();
						this.ctx.moveTo(this.roundWidth * this.totalRounds + (this.roundWidth * (Math.log2(this.participants.length / 2)) - ((i -1) * this.roundWidth)),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo(this.roundWidth * this.totalRounds + (this.roundWidth * (Math.log2(this.participants.length / 2)) - ((i -1) * this.roundWidth)) - (this.roundWidth / 4),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.stroke();
						
						if(j % 2 ==0) 
						{
						//vertical movement
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,((this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2) + (this.cellHeight * Math.pow(2, i + 1)));
						this.ctx.stroke();
						//vertical movement 2
						this.ctx.beginPath();
						this.ctx.moveTo(this.roundWidth * this.totalRounds + (this.roundWidth * (Math.log2(this.participants.length / 2)) - ((i -1) * this.roundWidth)) - (this.roundWidth / 4),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2);
						this.ctx.lineTo(this.roundWidth * this.totalRounds + (this.roundWidth * (Math.log2(this.participants.length / 2)) - ((i -1) * this.roundWidth)) - (this.roundWidth / 4),((this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight / 2) + (this.cellHeight * Math.pow(2, i + 1)));
						this.ctx.stroke();
						//Relation Line
						this.ctx.beginPath();
						this.ctx.strokeStyle = this.bracketsColor;
						this.ctx.moveTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 4,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i) + this.cellHeight / 2);
						this.ctx.lineTo((this.roundWidth * i) + this.cellWidth + this.roundWidth / 2.5,(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i)+ this.cellHeight / 2);
						this.ctx.stroke();
						//Relation Line 2
						this.ctx.beginPath();
						this.ctx.moveTo(this.roundWidth * this.totalRounds + (this.roundWidth * (Math.log2(this.participants.length / 2)) - ((i -1) * this.roundWidth)) - (this.roundWidth / 4),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i) + this.cellHeight / 2);
						this.ctx.lineTo(this.roundWidth * this.totalRounds + (this.roundWidth * (Math.log2(this.participants.length / 2)) - ((i -1) * this.roundWidth)) - (this.roundWidth / 2.5),(this.cellHeight *  Math.pow(2, i) - (this.cellHeight)) + (this.cellHeight * (j * Math.pow(2, i + 1))) + this.cellHeight * Math.pow(2, i) + this.cellHeight / 2);
						this.ctx.stroke();
						}
					}
				break;
			}
			
		}
		
		this.self = this;
			
}

Tournament.prototype.locateParticipants = function() {
	
			var locations = this.participants.slice(0,this.participants.length);
	
			for(j=0; j < this.participants.length; j++) 
			{
				var number = Math.floor(Math.random() * (locations.length));
				
				var element = locations.slice(number,number + 1);
				
				this.cellCords[j].element = element[0];
				
				locations.splice(number,1);
				
				this.drawParticipant(this.cellCords[j],true);
			}
			
			this.self = this;
}